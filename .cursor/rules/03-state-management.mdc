---
globs: ["**/*.ts", "**/*.tsx"]
---

# 状態管理

## 基本方針

### 1. リモートデータは「サーバーフェッチスナップショット」と「サーバーステート」で管理

リモートデータは、「サーバーフェッチスナップショット」と「サーバーステート」で管理し、「各画面で都度fetch + キャッシュ」で管理します。

従来のグローバルステートでリモートデータを管理する方法から、Next.js 15 / React 19の標準機能を活用した方法へと移行します。

### 2. グローバルステートは極力使用しない

グローバルステートは極力使用せず、基本方針1で対応できないデータの場合のみ「小中規模グローバルステート」の導入を検討します。

グローバルステートは、再レンダリングの範囲が広くなりがちで、コードの複雑化やデバッグが困難になりやすいため、慎重に使用する必要があります。

### 3. 「SSOT（データの主軸）」と「スコープ」を基準にステートを選定

「SSOT（Single Source of Truth：データの主軸）」と「スコープ」を基準にステートを選定します。

データの主軸がどこにあるか（サーバー or クライアント）、どのスコープで使用されるか（単一コンポーネントや複数画面など）を明確にすることで、適切な状態管理の手段を選択できます。

## ユースケースと実装方法

| # | ユースケース | カテゴリ | 実装方法 |
| --- | --- | --- | --- |
| 1 | クライアントデータ + 単一コンポーネント | ローカルステート | useState, useReducer |
| 2 | クライアントデータ + 複数コンポーネント・複数画面 | 小中規模グローバルステート | useContext, Zustand, Jotai |
| 3 | 大規模アプリ + 複雑な横断状態・連動 + 一元管理 | 大規模グローバルステート | Redux Toolkit |
| 4 | リモートデータ + サーバーフェッチ | サーバーフェッチスナップショット | Server Component + fetch + Data Cache |
| 5 | リモートデータ + クライアントフェッチ | サーバーステート | TanStack Query |
| 6 | 現在の操作状態の再現・共有、リロード保持 | URLステート | searchParams/useSearchParams + Link/router.replace/history.replaceState |
| 7 | 入力値・バリデーション管理 | フォームステート | React Hook Form + zod |
| 8 | セッション間・タブ間共有、リロード保持、オフラインキャッシュ | ブラウザステート | localStorage, sessionStorage, IndexedDB |
| 9 | ユーザー識別 + 機密情報 | セッション / 認証ステート | httpOnly Cookie、 Redis |

## 1. クライアントデータ + 単一コンポーネント

### 概要

単一コンポーネント内でのみ使用するクライアント専用の状態を管理するパターンです。モーダルの開閉状態、タブの選択状態、表示フラグの管理など、そのコンポーネント内でのみ完結する状態管理に使用します。

### 実装方法

1. useState
2. useReducer

### サンプルコード

components/Modal.tsx

```tsx
'use client';

import { useState } from 'react';

export function Modal() {
  const [isOpen, setIsOpen] = useState(false);

  return (
    <div>
      <button onClick={() => setIsOpen(true)}>モーダルを開く</button>

      {isOpen && (
        <div className="modal">
          <div className="modal-content">
            <h2>モーダル</h2>
            <p>モーダルの内容</p>
            <button onClick={() => setIsOpen(false)}>閉じる</button>
          </div>
        </div>
      )}
    </div>
  );
}
```

## 2. クライアントデータ + 複数コンポーネント・複数画面

### 概要

複数のコンポーネントや画面にまたがって共有する必要があるクライアント専用の状態を管理するパターンです。検索条件の共有、テーマ設定、トースト通知、モーダルの状態管理など、複数のコンポーネント間で同期が必要な状態に使用します。

### 実装方法

1. useContext
2. Zustand or Jotai

### サンプルコード（useContext）

providers/ThemeProvider.tsx

```tsx
'use client';

import { createContext, useContext, useState, type ReactNode } from 'react';

type Theme = 'light' | 'dark';

type ThemeContextType = {
  theme: Theme;
  setTheme: (theme: Theme) => void;
};

const ThemeContext = createContext<ThemeContextType | undefined>(undefined);

export function ThemeProvider({ children }: { children: ReactNode }) {
  const [theme, setTheme] = useState<Theme>('light');

  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}

export function useTheme() {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error('useTheme must be used within ThemeProvider');
  }
  return context;
}
```

### サンプルコード（Zustand）

stores/searchStore.ts

```ts
import { create } from 'zustand';

type SearchState = {
  query: string;
  status: string;
  setQuery: (query: string) => void;
  setStatus: (status: string) => void;
  reset: () => void;
};

export const useSearchStore = create<SearchState>((set) => ({
  query: '',
  status: 'all',
  setQuery: (query) => set({ query }),
  setStatus: (status) => set({ status }),
  reset: () => set({ query: '', status: 'all' }),
}));
```

components/SearchForm.tsx

```tsx
'use client';

import { useSearchStore } from '@/stores/searchStore';

export function SearchForm() {
  // 部分購読: queryのみを購読
  const query = useSearchStore((state) => state.query);
  const setQuery = useSearchStore((state) => state.setQuery);

  return (
    <input
      type="text"
      value={query}
      onChange={(e) => setQuery(e.target.value)}
      placeholder="検索キーワード"
    />
  );
}
```

## 3. 大規模アプリ + 複雑な横断状態・連動 + 一元管理

### 概要

大規模なアプリケーションで、複雑なビジネスロジックを持つ横断的な状態や、複数ドメインにまたがる厳格な一元管理が必要な場合のパターンです。

ただし、Next.js 15 / React 19では、Server Component、TanStack Query、Zustandの組み合わせで大半のユースケースに対応できるため、基本的に大規模グローバルステートは不要です。

### 実装方法

Redux Toolkit

## 4. リモートデータ + サーバーフェッチ

### 概要

初回レンダリング時にServer Componentでサーバー側からデータを取得し、そのスナップショットを状態管理として扱うパターンです。

**Next.js 15では、このパターンがリモートデータ取得の第一優先です。**

### 実装方法

Server Component + fetch + Data Cache

### サンプルコード

app/tasks/page.tsx

```tsx
import { fetchTasks } from '@/apis/tasks.server';
import { TaskList } from './_components/TaskList';

export default async function TasksPage() {
  const result = await fetchTasks();

  if (!result.isSuccess) {
    return <p>タスクの取得に失敗しました</p>;
  }

  return (
    <div>
      <h1>タスク一覧</h1>
      <TaskList tasks={result.data} />
    </div>
  );
}
```

apis/tasks.server.ts

```ts
import { request } from '@/lib/request';
import type { Result } from '@/types/result';
import type { Task } from '@/types/task';

export async function fetchTasks(): Promise<Result<Task[]>> {
  const res = await fetch(
    `${process.env.BASE_URL}/api/tasks`,
    {
      cache: 'force-cache',
      next: {
        tags: ['tasks'],
      },
    },
  );

  if (!res.ok) {
    throw new Error(res.statusText);
  }

  return await res.json();
}
```

## 5. リモートデータ + クライアントフェッチ

### 概要

ユーザーの操作をトリガーとしてクライアント側でデータを取得し、TanStack Queryでキャッシュや状態を管理するパターンです。

検索結果の取得、フィルタ・ソート操作、詳細モーダルの遅延取得、無限スクロールなど、ユーザーのインタラクションに応じて動的にデータを取得する際に使用します。

### 実装方法

TanStack Query

### サンプルコード

components/TaskList.tsx

```tsx
'use client';

import { useQuery } from '@tanstack/react-query';
import { fetchTasks } from '@/apis/tasks.client';

export function TaskList() {
  const { data: tasks, isLoading, error } = useQuery({
    queryKey: ['tasks'],
    queryFn: fetchTasks,
    staleTime: 5 * 60 * 1000,
  });

  if (isLoading) return <p>読み込み中...</p>;
  if (error) return <p>エラーが発生しました</p>;

  return (
    <ul>
      {tasks?.map((task) => (
        <li key={task.id}>{task.title}</li>
      ))}
    </ul>
  );
}
```

## 6. 現在の操作状態の再現・共有、リロード保持

### 概要

ユーザーの操作状態をURLパラメータに反映し、ブラウザの戻る・進むやURLの共有によって、現在の状態を再現できるようにするパターンです。

検索条件、ページネーション、タブの選択状態など、リロードやURL共有時に保持したい画面状態の管理に使用します。

### 実装方法

- **取得** ：searchParams or useSearchParams
- **更新** ：Link or router.replace or history.replaceState

### サンプルコード

app/search/page.tsx

```tsx
import Link from 'next/link';
import { fetchSearchResults } from '@/apis/search.server';

type Props = {
  searchParams: Promise<{ query?: string; status?: string }>;
};

export default async function SearchPage({ searchParams }: Props) {
  const params = await searchParams;
  const query = params.query || '';
  const status = params.status || 'all';

  const result = await fetchSearchResults(query, status);

  if (!result.isSuccess) {
    return <p>検索結果の取得に失敗しました</p>;
  }

  return (
    <div>
      <h1>検索結果</h1>

      <div>
        <Link href={`/search?query=${query}&status=all`}>すべて</Link>
        <Link href={`/search?query=${query}&status=active`}>アクティブ</Link>
        <Link href={`/search?query=${query}&status=inactive`}>非アクティブ</Link>
      </div>

      <ul>
        {result.data.map((item) => (
          <li key={item.id}>{item.title}</li>
        ))}
      </ul>
    </div>
  );
}
```

## 7. 入力値・バリデーション管理

### 概要

フォームの入力値とバリデーションを管理するパターンです。`React Hook Form` と `zod` を組み合わせることで、型安全かつ宣言的なバリデーションを実現できます。

### 実装方法

React Hook Form + zod

### サンプルコード

components/SimpleForm.tsx

```tsx
'use client';

import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';

const schema = z.object({
  email: z.string().email('有効なメールアドレスを入力してください'),
  password: z.string().min(8, 'パスワードは8文字以上で入力してください'),
});

type FormData = z.infer<typeof schema>;

export function SimpleForm() {
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
  } = useForm<FormData>({
    resolver: zodResolver(schema),
  });

  const onSubmit = async (data: FormData) => {
    console.log(data);
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <div>
        <label>メールアドレス</label>
        <input type="email" {...register('email')} />
        {errors.email && <p>{errors.email.message}</p>}
      </div>

      <div>
        <label>パスワード</label>
        <input type="password" {...register('password')} />
        {errors.password && <p>{errors.password.message}</p>}
      </div>

      <button type="submit" disabled={isSubmitting}>
        {isSubmitting ? '送信中...' : '送信'}
      </button>
    </form>
  );
}
```

## 8. セッション間・タブ間共有、リロード保持、オフラインキャッシュ

### 概要

ブラウザストレージ（localStorage、sessionStorage、IndexedDB）を使用して、クライアント専用の状態をブラウザに永続化するパターンです。

### 実装方法

1. localStorage
2. sessionStorage
3. IndexedDB

| 種別 | ユースケース | 特徴 |
| --- | --- | --- |
| localStorage | テーマ設定、言語選択、ユーザー設定など | ブラウザ再起動後も保持、約5〜10MBの容量 |
| sessionStorage | マルチステップフォーム、セッション中の一時状態 | タブ単位で独立、約5〜10MBの容量 |
| IndexedDB | 大容量データのキャッシュ、オフライン対応、複雑データ保存 | 非同期API、数十〜数百MB以上が容量 |

## 9. ユーザー識別 + 機密情報

### 概要

ユーザー認証や機密情報を含むセッションデータを安全に管理するパターンです。httpOnly Cookieを使用してアクセストークンやセッションIDをクライアントJSからアクセス不可にし、サーバー側でのみ参照・検証することで、XSS攻撃からの耐性を確保します。

### 実装方法

httpOnly Cookie、Redis

### 補足

Next.jsの `cookies()` 関数を使用することで、サーバー側からhttpOnly Cookieを参照できます。

## エッジケース

基本的にデータの二重管理は禁止ですが、複雑な要件によっては併用することも検討します。
