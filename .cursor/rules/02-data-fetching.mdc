---
alwaysApply: true
---
# データ取得

## 基本方針

### 1. Next.js 16: 動的がデフォルト、必要に応じてキャッシュ

**Next.js 16では、すべてのデータ取得は動的がデフォルトです。** Server Componentで直接データを取得し、必要に応じて`use cache`でキャッシュを有効にします。

### 2. キャッシュ戦略の基準

データの性質に応じてキャッシュ戦略を選択します：

- **キャッシュする**: マスタデータ、コンテンツ、低頻度更新データ → `use cache`を使用
- **キャッシュしない**: リアルタイムデータ、ユーザーセッション、高頻度更新データ → 動的レンダリング
- **迷ったら**: まずキャッシュせず実装し、パフォーマンス測定後に判断

### 3. クライアントフェッチはTanStack QueryとRoute Handlerを使用

クライアントフェッチの場合は、TanStack Queryを使用し、必ずRoute Handlerを経由して外部APIを叩きます。

### 4. データフェッチコロケーション

基本的にデータが必要なコンポーネントで直接フェッチをします。

データが必要な場所で直接取得することでコンポーネントの独立性が向上し、その結果再利用性が高まります。また、Props Drillingのデメリットも解消されます。

## ユースケースと実装方法

| # | ユースケース | 概要 | 実装方法 |
| --- | --- | --- | --- |
| 1 | 初回レンダリング時（静的・キャッシュ可能） | マスタデータ、コンテンツなど | Server Component + `use cache` + `cacheLife` |
| 2 | 初回レンダリング時（動的・ユーザー依存） | ログインユーザー固有情報、認証必須メニューなど | Server Component + `use cache: private` or 動的レンダリング + Suspense |
| 3 | 初回レンダリング時（ランタイムAPI使用） | cookies, headersなどを使用 | Server Component + 動的レンダリング + Suspense |
| 4 | 初回レンダリング時（クライアント専用データ） | DBで保持しているデータをクライアントのみで利用 | Server Component + Client Component + use + Suspense |
| 5 | ユーザー操作時 | 画面操作によってデータを取得（検索・フィルタ・ソート等） | Client Component + useQuery + Route Handler |
| 6 | 初回レンダリング時 + ユーザー操作時 | 初回描画で一覧を取得、以降はユーザー操作で再取得 | Server Component + prefetchQuery + HydrationBoundary + useQuery |
| 7 | 依存クエリ | 先行入力に依存して次のデータを取得（都道府県→市区町村など） | Client Component + useQuery + enabled |
| 8 | プリフェッチ | 次に開かれる可能性のあるデータを先読み | Server Component + Link + prefetch or router.prefetch |

## 1. 初回レンダリング時（静的・キャッシュ可能）

### 概要

マスタデータやコンテンツなど、変更頻度が低く複数のリクエストで共有できるデータを`use cache`でキャッシュするパターンです。

このパターンでは、カテゴリ一覧、国・都道府県リスト、お知らせ、利用規約、ブログ記事など、低〜中頻度で更新されるデータの取得時に使用します。

### サンプルコード

#### パターンA: 関数レベルでキャッシュ

apis/features.server.ts

```ts
import { cacheTag, cacheLife } from 'next/cache'
import type { Feature } from '@/types/feature'

export async function fetchFeatures() {
  'use cache'
  cacheTag('features')
  cacheLife('days') // 1日キャッシュ
  
  const res = await fetch(`${process.env.BASE_URL}/api/features`)
  
  if (!res.ok) {
    throw new Error(res.statusText)
  }
  
  return await res.json()
}
```

#### パターンB: コンポーネントレベルでキャッシュ

app/features/components/FeatureList.tsx

```tsx
import { cacheTag, cacheLife } from 'next/cache'

export async function FeatureList() {
  'use cache'
  cacheTag('features')
  cacheLife('hours') // 1時間キャッシュ
  
  const res = await fetch(`${process.env.BASE_URL}/api/features`)
  const features = await res.json()
  
  return (
    <ul>
      {features.map((feature) => (
        <li key={feature.id}>{feature.name}</li>
      ))}
    </ul>
  )
}
```

app/features/page.tsx

```tsx
import { Suspense } from 'react'
import { FeatureList } from './components/FeatureList'

export default function FeaturesPage() {
  return (
    <div>
      <h1>機能一覧</h1>
      <Suspense fallback={<p>読み込み中...</p>}>
        <FeatureList />
      </Suspense>
    </div>
  )
}
```

## 2. 初回レンダリング時（動的・ユーザー依存）

### 概要

ユーザー固有のデータをサーバーで取得するパターンです。`use cache: private`を使ってユーザーごとにキャッシュするか、動的レンダリングで毎回取得するか選択します。

このパターンでは、ダッシュボードのユーザー統計情報、マイページのプロフィール、購入履歴など、初期描画時に必要なユーザー固有データの取得時に使用します。

### サンプルコード

#### パターンA: ユーザー固有データをキャッシュ（use cache: private）

apis/users.server.ts

```ts
import { cacheTag, cacheLife } from 'next/cache'
import type { UserProfile } from '@/types/user'

export async function fetchUserProfile(userId: string) {
  'use cache: private'
  cacheTag(`user-${userId}`)
  cacheLife('minutes') // 5分キャッシュ
  
  const res = await fetch(`${process.env.BASE_URL}/api/users/${userId}`)
  
  if (!res.ok) {
    throw new Error(res.statusText)
  }
  
  return await res.json()
}
```

app/profile/page.tsx

```tsx
import { Suspense } from 'react'
import { cookies } from 'next/headers'
import { fetchUserProfile } from '@/apis/users.server'
import { UserProfile } from './components/UserProfile'

export default async function ProfilePage() {
  const cookieStore = await cookies()
  const userId = cookieStore.get('userId')?.value
  
  if (!userId) {
    return <p>ログインしてください</p>
  }
  
  return (
    <div>
      <h1>プロフィール</h1>
      <Suspense fallback={<p>読み込み中...</p>}>
        <UserProfile userId={userId} />
      </Suspense>
    </div>
  )
}
```

app/profile/components/UserProfile.tsx

```tsx
import { fetchUserProfile } from '@/apis/users.server'

type Props = {
  userId: string
}

export async function UserProfile({ userId }: Props) {
  const profile = await fetchUserProfile(userId)
  
  return (
    <div>
      <p>名前: {profile.name}</p>
      <p>メール: {profile.email}</p>
    </div>
  )
}
```

#### パターンB: 動的レンダリング（キャッシュなし）

リアルタイム性が求められるデータや、キャッシュする必要がないデータは`use cache`を使わずに動的レンダリングします。

apis/dashboard.server.ts

```ts
import type { DashboardStats } from '@/types/dashboard'

export async function fetchDashboardStats(userId: string) {
  // use cacheを使わない = 常に最新データを取得
  const res = await fetch(`${process.env.BASE_URL}/api/dashboard/${userId}`)
  
  if (!res.ok) {
    throw new Error(res.statusText)
  }
  
  return await res.json()
}
```

## 3. 初回レンダリング時（ランタイムAPI使用）

### 概要

`cookies()`, `headers()`, `searchParams`などのランタイムAPIを使用するコンポーネントは、`use cache`を使えないため、必ずSuspenseでラップして動的レンダリングします。

Cache Componentsでは、ランタイムAPIを使うコンポーネントがSuspenseでラップされていない場合、エラーになります。

### サンプルコード

app/user/components/UserMenu.tsx

```tsx
import { cookies } from 'next/headers'

export async function UserMenu() {
  // cookies()を使うので use cache は使えない
  const session = (await cookies()).get('session')?.value
  
  if (!session) {
    return <a href="/login">ログイン</a>
  }
  
  return (
    <nav>
      <a href="/profile">プロフィール</a>
      <button>ログアウト</button>
    </nav>
  )
}
```

app/layout.tsx

```tsx
import { Suspense } from 'react'
import { UserMenu } from './components/UserMenu'

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html>
      <body>
        <header>
          {/* ランタイムAPIを使うコンポーネントはSuspenseでラップ */}
          <Suspense fallback={<div>読み込み中...</div>}>
            <UserMenu />
          </Suspense>
        </header>
        {children}
      </body>
    </html>
  )
}
```

## 4. 初回レンダリング時（クライアント専用データ）

### 概要

初期描画時に必要なデータであり、かつクライアントコンポーネントでのみ使用するデータを取得する場合です。Server Componentでデータを取得し、Promiseのまま渡すことで、Client Componentでも効率的なストリーミングレンダリングを実現できます。

### サンプルコード

app/profile/edit/page.tsx

```tsx
import { Suspense } from 'react';
import { fetchUserProfile } from '@/apis/users.server';
import { ProfileEditForm } from './components/ProfileEditForm';

export default function ProfileEditPage() {
  const profilePromise = fetchUserProfile();

  return (
    <div>
      <h1>プロフィール編集</h1>
      <Suspense fallback={<p>プロフィールを読み込み中...</p>}>
        <ProfileEditForm profilePromise={profilePromise} />
      </Suspense>
    </div>
  );
}
```

app/profile/edit/components/ProfileEditForm.tsx

```tsx
'use client';

import { use } from 'react';
import type { Result } from '@/types/result';
import type { UserProfile } from '@/types/user';

type Props = {
  profilePromise: Promise<Result<UserProfile>>;
};

export function ProfileEditForm({ profilePromise }: Props) {
  const result = use(profilePromise);

  if (!result.isSuccess) {
    return <p>プロフィールの取得に失敗しました</p>;
  }

  const { data: profile } = result;

  return (
    <form>
      <label>
        名前:
        <input type="text" defaultValue={profile.name} />
      </label>
      <label>
        メール:
        <input type="email" defaultValue={profile.email} />
      </label>
      <button type="submit">保存</button>
    </form>
  );
}
```

## 5. ユーザー操作時

### 概要

ユーザーの操作をトリガーとしてデータを取得する場合です。TanStack QueryとRoute Handlerを組み合わせることで、クライアント側のキャッシュ管理を効率的に行いながら、データ取得を実現します。

このパターンでは、検索・フィルタ・ソート・ページネーション・モーダル開閉など、ユーザーのインタラクションに応じてデータを取得する際に使用します。

> **Good to know**: サーバー側のキャッシュ（`use cache`）とクライアント側のキャッシュ（TanStack Query）は併用を避けます。キャッシュレイヤーを混在させると整合性管理が複雑になります。

### サンプルコード

app/tasks/_components/TaskTable.tsx

```tsx
'use client';

import { useQuery } from '@tanstack/react-query';
import { useState } from 'react';
import { fetchTasks } from '@/apis/tasks.client';

export function TaskTable() {
  const [sortKey, setSortKey] = useState<'createdAt' | 'priority'>('createdAt');

  const { data, isLoading, error } = useQuery({
    queryKey: ['tasks', sortKey],
    queryFn: () => fetchTasks(sortKey),
    staleTime: 5 * 60 * 1000,
  });

  if (isLoading) return <p>読み込み中...</p>;
  if (error) return <p>エラーが発生しました</p>;

  return (
    <div>
      <div>
        <button onClick={() => setSortKey('createdAt')}>作成日順</button>
        <button onClick={() => setSortKey('priority')}>優先度順</button>
      </div>
      <table>
        <thead>
          <tr>
            <th>タイトル</th>
            <th>優先度</th>
            <th>作成日</th>
          </tr>
        </thead>
        <tbody>
          {data?.map((task) => (
            <tr key={task.id}>
              <td>{task.title}</td>
              <td>{task.priority}</td>
              <td>{task.createdAt}</td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}
```

apis/tasks.client.ts

```ts
import type { Task } from '@/types/task';

export async function fetchTasks(sortKey: 'createdAt' | 'priority'): Promise<Task[]> {
  const res = await fetch(`/api/tasks?sort=${sortKey}`);

  if (!res.ok) {
    throw new Error('Failed to fetch tasks');
  }

  return await res.json();
}
```

app/api/tasks/route.ts

```ts
import { NextRequest, NextResponse } from 'next/server';
import { fetchTasksFromExternalAPI } from '@/lib/externalApi';

export async function GET(request: NextRequest) {
  const searchParams = request.nextUrl.searchParams;
  const sortKey = searchParams.get('sort') || 'createdAt';

  const tasks = await fetchTasksFromExternalAPI(sortKey);

  return NextResponse.json(tasks);
}
```

## 6. 初回レンダリング時 + ユーザー操作時（ハイブリッド）

### 概要

初回レンダリング時はServer Componentでサーバーフェッチを行い、レンダリング後のユーザー操作でのデータフェッチは、Client ComponentでTanStack Queryを使用し再取得する、ハイブリッドなデータ取得パターンです。

> **Good to know**: サーバー側で`use cache`を使っている場合は、このパターンは使用しません。`use cache`とTanStack Queryの併用は避けます。

### サンプルコード

app/search/page.tsx

```tsx
import { Suspense } from 'react';
import { HydrationBoundary, dehydrate } from '@tanstack/react-query';
import { getQueryClient } from '@/lib/queryClient';
import { fetchSearchResults } from '@/apis/search.server';
import { SearchResults } from './components/SearchResults';

type Props = {
  searchParams: Promise<{[key: string]: string}>
}

export default async function SearchPage({ searchParams }: Props) {
  const queryClient = getQueryClient();
  const params = await searchParams;
  const searchConditions = convertSearchConditions(params);

  await queryClient.prefetchQuery({
    queryKey: ['search', searchConditions],
    queryFn: () => fetchSearchResults(searchConditions),
  });

  const dehydratedState = dehydrate(queryClient);

  return (
    <div>
      <h1>検索</h1>
      <HydrationBoundary state={dehydratedState}>
        <SearchResults />
      </HydrationBoundary>
    </div>
  );
}
```

app/search/components/SearchResults.tsx

```tsx
'use client';

import { useQuery } from '@tanstack/react-query';
import { useState } from 'react';
import { fetchSearchResultsClient } from '@/apis/search.client';
import { useSearchConditions } from '@/hooks/useSearchConditions';

export function SearchResults() {
  const [query, setQuery] = useState('');
  const searchConditions = useSearchConditions();

  const { data, isLoading } = useQuery({
    queryKey: ['search', searchConditions],
    queryFn: () => fetchSearchResultsClient(query),
    staleTime: 5 * 60 * 1000,
    refetchOnMount: false
  });

  return (
    <div>
      <input
        type="text"
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder="検索キーワード"
      />
      {isLoading ? (
        <p>検索中...</p>
      ) : (
        <ul>
          {data?.map((result) => (
            <li key={result.id}>{result.title}</li>
          ))}
        </ul>
      )}
    </div>
  );
}
```

## 7. 依存クエリ／タイプアヘッド／インクリメンタル検索

### 概要

あるデータの選択や入力に依存して、次のデータを取得する場合です。TanStack Queryの `enabled` オプションを活用することで、依存する値が存在する場合のみクエリを実行できます。

### サンプルコード

app/address/components/AddressForm.tsx

```tsx
'use client';

import { useQuery } from '@tanstack/react-query';
import { useState } from 'react';
import { fetchPrefectures, fetchCities } from '@/apis/address.client';

export function AddressForm() {
  const [selectedPrefecture, setSelectedPrefecture] = useState('');

  const { data: prefectures } = useQuery({
    queryKey: ['prefectures'],
    queryFn: fetchPrefectures,
  });

  const { data: cities, isLoading: isCitiesLoading } = useQuery({
    queryKey: ['cities', selectedPrefecture],
    queryFn: () => fetchCities(selectedPrefecture),
    enabled: !!selectedPrefecture,
  });

  return (
    <div>
      <label>
        都道府県:
        <select
          value={selectedPrefecture}
          onChange={(e) => setSelectedPrefecture(e.target.value)}
        >
          <option value="">選択してください</option>
          {prefectures?.map((pref) => (
            <option key={pref.id} value={pref.id}>
              {pref.name}
            </option>
          ))}
        </select>
      </label>

      {selectedPrefecture && (
        <label>
          市区町村:
          <select disabled={isCitiesLoading}>
            <option value="">選択してください</option>
            {cities?.map((city) => (
              <option key={city.id} value={city.id}>
                {city.name}
              </option>
            ))}
          </select>
        </label>
      )}
    </div>
  );
}
```

## 8. プリフェッチ

### 概要

ユーザーが次に遷移する可能性の高いページのルートとデータを事前に読み込む（プリフェッチする）ことで、ページ遷移時の体感速度を向上させる手法です。

ただし、一覧画面のように多数のリンクがある場合、すべてをプリフェッチするとN+1問題のように無駄なリクエストが大量に発生してしまいます。プリフェッチの有効化は慎重に判断する必要があります。

### 実装方法

#### 1. Linkコンポーネントのprefetchプロパティ

Server ComponentまたはClient ComponentでLinkコンポーネントを使用し、 `prefetch` プロパティで制御します。

#### 2. router.prefetch()メソッド

Client Componentで `useRouter` フックを使用し、自由なタイミングでプリフェッチを制御します。

### サンプルコード

app/dashboard/page.tsx

```tsx
import Link from 'next/link';
import { fetchDashboardStats } from '@/apis/dashboard.server';

export default async function DashboardPage() {
  const result = await fetchDashboardStats();

  if (!result.isSuccess) {
    return <p>ダッシュボードの読み込みに失敗しました</p>;
  }

  return (
    <div>
      <h1>ダッシュボード</h1>
      <p>売上: {result.data.sales}</p>
      <p>ユーザー数: {result.data.users}</p>

      <Link href="/settings" prefetch={true}>
        設定画面へ
      </Link>
    </div>
  );
}
```
