---
alwaysApply: true
---
# キャッシュ戦略

## 基本方針

### Next.js 16: 動的がデフォルト、必要な部分を明示的にキャッシュ

Next.js 15から、Data CacheやRouter Cacheがデフォルトでオフになり、キャッシュはオプトイン（明示的な有効化が必要）という立ち位置になりました。

**Next.js 16では、この考え方がさらに進化し、`use cache`ディレクティブによる細かい粒度でのキャッシュ制御が標準となります。**

### 基本原則

1. **動的がデフォルト**: 全てのページ・コンポーネントはデフォルトで動的レンダリング
2. **明示的なキャッシュ**: `use cache`を使って必要な部分だけをキャッシュ
3. **Suspenseで動的部分を分離**: 動的データは`Suspense`でラップしてストリーミング
4. **慎重な最適化**: キャッシュの制御を誤ると、「古いデータが表示される」「UIとDBの状態が不整合になる」問題が発生

## キャッシュレイヤーの整理

Next.js 15/16では、複数のキャッシュレイヤーが協調して動作します。それぞれの役割と特性を理解することで、適切なキャッシュ戦略を設計できます。

| キャッシュ名 | 場所 | 目的 | 期間 | 制御方法 | 優先度 |
| --- | --- | --- | --- | --- | --- |
| Request Memoization | サーバー | 同一レンダー内の重複fetch排除 | レンダー中のみ | 自動（制御不可） | - |
| **Component Cache** | **サーバー** | **コンポーネント/関数のキャッシュ** | **設定による** | **`use cache` + `cacheLife`** | **⭐️高** |
| Data Cache (legacy) | サーバー | サーバーフェッチの結果をキャッシュ | 永続的（再検証まで） | `next.revalidate` 、 `revalidateTag` | 低（非推奨） |
| TanStack Query Cache | クライアント | クライアントフェッチの結果をキャッシュ | 設定による | `staleTime` 、 `gcTime` 、 `invalidateQueries` | 中 |
| Router Cache | クライアント | ページ遷移時のキャッシュ | セッション中 | next.configの `staleTimes` で設定 | - |

> **Good to know**: Next.js 16では、従来のData Cache（`fetch`の`next.revalidate`オプション）よりも、`use cache`を使ったComponent Cacheが推奨されます。

## Full Route Cacheのルール

Full Route Cacheは、ビルド時にページのレンダリング結果をキャッシュし、リクエストごとの再レンダリングを不要にする仕組みです（従来のSSGに相当します）。

### ルートグループで静的・動的を分離する

ルートグループを使って静的ページと動的ページのディレクトリを分離し、それぞれに専用の `layout.tsx` を配置します。

#### OK例: ルートグループで分離

app/layout.tsx

```tsx
// ✅ Good: 動的APIを使用しない
export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html>
      <body>
        {children}
      </body>
    </html>
  );
}
```

app/(static)/layout.tsx

```tsx
// ✅ Good: 動的APIを使用しない
export default function PublicLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <div>
      <header>Public Header</header>
      {children}
    </div>
  );
}
```

app/(dynamic)/layout.tsx

```tsx
import { cookies } from 'next/headers';

// ✅ Good: このルートグループ内のみ動的レンダリング
export default async function PrivateLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const cookieStore = await cookies();
  const token = cookieStore.get('auth-token');

  return (
    <div>
      <header>Private Header (User: {token?.value})</header>
      {children}
    </div>
  );
}
```

#### NG例: ルートのlayout.tsxで動的API使用

```tsx
import { cookies } from 'next/headers';

// ❌ Bad: 全画面が動的レンダリングになる
export default async function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const cookieStore = await cookies();
  const token = cookieStore.get('auth-token');

  return (
    <html>
      <body>
        <header>User: {token?.value}</header>
        {children}
      </body>
    </html>
  );
}
```

## use cacheの使用ルール（Next.js 16推奨）

Next.js 16では、`use cache`ディレクティブを使ってコンポーネントや関数をキャッシュします。これは従来のData Cacheよりも柔軟で、DBクエリやAPI呼び出しなど、あらゆるサーバー側の処理をキャッシュできます。

### 1. データの性質別キャッシュ戦略

データの更新頻度と共有範囲によってキャッシュ戦略を決定します：

#### パターンA: マスタデータ（更新頻度: 低、共有: 全ユーザー）

```typescript
// カテゴリ、国・都道府県リスト、利用規約など
export async function fetchCategories() {
  'use cache'
  cacheTag('categories')
  cacheLife('days') // 1日キャッシュ
  
  const data = await db.query('SELECT * FROM categories')
  return data
}
```

#### パターンB: 半動的データ（更新頻度: 中、共有: 全ユーザー）

```typescript
// ブログ記事、お知らせ、商品一覧など
export async function fetchPosts() {
  'use cache'
  cacheTag('posts')
  cacheLife('hours') // 1時間キャッシュ
  
  const data = await db.query('SELECT * FROM posts ORDER BY created_at DESC')
  return data
}

export async function fetchPost(id: string) {
  'use cache'
  cacheTag('posts', `post-${id}`)
  cacheLife('hours')
  
  const data = await db.query('SELECT * FROM posts WHERE id = ?', [id])
  return data
}
```

#### パターンC: ユーザー固有データ（更新頻度: 中、共有: 個別ユーザー）

```typescript
// ユーザープロフィール、設定、購入履歴など
export async function fetchUserProfile(userId: string) {
  'use cache: private'
  cacheTag(`user-${userId}`)
  cacheLife('minutes') // 5分キャッシュ
  
  const data = await db.query('SELECT * FROM users WHERE id = ?', [userId])
  return data
}
```

#### パターンD: リアルタイムデータ（更新頻度: 高、共有: 全ユーザー）

```typescript
// ライブフィード、チャット、リアルタイム在庫など
export async function fetchLiveFeed() {
  // use cacheを使わない = 常に最新データを取得
  const data = await db.query('SELECT * FROM live_feed ORDER BY created_at DESC LIMIT 50')
  return data
}
```

### 2. コンポーネント層でのキャッシュ

```tsx
// ケース1: 完全静的コンポーネント
export async function SiteHeader() {
  'use cache'
  cacheLife('days')
  
  const siteConfig = await fetchSiteConfig()
  return <header>{siteConfig.title}</header>
}

// ケース2: パラメータに依存するコンポーネント
export async function ProductList({ category }: { category: string }) {
  'use cache'
  cacheTag('products', `products-${category}`)
  cacheLife('hours')
  
  const products = await fetchProductsByCategory(category)
  return <div>{/* ... */}</div>
}

// ケース3: ランタイムAPIを使うコンポーネント（キャッシュ不可）
export async function UserMenu() {
  // cookies()を使うのでuse cacheは使えない
  // Suspenseでラップして動的レンダリング
  const session = (await cookies()).get('session')?.value
  return <div>{/* ... */}</div>
}
```

### 3. ページ層でのキャッシュ

```tsx
// ケース1: 完全静的ページ
export default async function AboutPage() {
  'use cache'
  cacheLife('days')
  
  return <div>About us...</div>
}

// ケース2: 部分的に動的なページ（PPR）
export default async function ProductPage({ params }: { params: Promise<{ id: string }> }) {
  const { id } = await params
  
  return (
    <>
      {/* 静的部分をキャッシュ */}
      <Suspense fallback={<Skeleton />}>
        <CachedProductInfo productId={id} />
      </Suspense>
      
      {/* 動的部分はキャッシュしない */}
      <Suspense fallback={<Skeleton />}>
        <UserRecommendations />
      </Suspense>
    </>
  )
}

async function CachedProductInfo({ productId }: { productId: string }) {
  'use cache'
  cacheTag(`product-${productId}`)
  cacheLife('hours')
  
  const product = await fetchProduct(productId)
  return <div>{/* ... */}</div>
}
```

### 4. cacheLifeの選択基準

| プロファイル | 期間 | 用途 |
| --- | --- | --- |
| `'seconds'` | 5秒 | ほぼリアルタイム、高頻度更新 |
| `'minutes'` | 5分 | ユーザー固有データ、中頻度更新 |
| `'hours'` | 1時間 | 半動的データ、商品一覧、記事一覧 |
| `'days'` | 1日 | マスタデータ、静的コンテンツ |
| カスタム | 任意 | `{ stale: 60, revalidate: 3600 }` |

### 5. キャッシュの再検証戦略

#### updateTag: 即座に更新を反映

ユーザーの操作直後に即座に反映すべきデータに使用します。

```typescript
import { cacheTag, updateTag } from 'next/cache'

export async function getCart(userId: string) {
  'use cache: private'
  cacheTag(`cart-${userId}`)
  cacheLife('minutes')
  // fetch data
}

export async function updateCartAction(userId: string, itemId: string) {
  'use server'
  // カートを更新
  await updateCart(userId, itemId)
  // 即座にキャッシュを更新
  updateTag(`cart-${userId}`)
}
```

#### revalidateTag: 次回リクエスト時に更新

静的コンテンツで即座の反映が不要な場合に使用します。

```typescript
import { cacheTag, revalidateTag } from 'next/cache'

export async function getPosts() {
  'use cache'
  cacheTag('posts')
  cacheLife('hours')
  // fetch data
}

export async function createPostAction(post: FormData) {
  'use server'
  // 記事を作成
  await createPost(post)
  // 次回リクエスト時に再検証
  revalidateTag('posts')
}
```

### 6. use cacheの制約

- **引数は直列化可能である必要**: プリミティブ、オブジェクト、配列のみ。関数やクラスインスタンスは不可
- **ランタイムAPIは使用不可**: `cookies()`, `headers()`, `searchParams`などは使えない
- **直列化不可の値も受け取れる**: `children`など、使用せず渡すだけなら可能

```tsx
// ✅ OK: childrenは使用しないので受け取れる
export async function CachedWrapper({ children }: { children: ReactNode }) {
  'use cache'
  const title = await getSiteTitle()
  
  return (
    <div className="wrapper">
      <h1>{title}</h1>
      {children}
    </div>
  )
}

// ❌ NG: cookies()は使用不可
export async function UserMenu() {
  'use cache'
  const session = (await cookies()).get('session')?.value // エラー
  return <div>{/* ... */}</div>
}
```

## Router Cacheのルール

Router Cacheは、クライアント側でページ遷移時のキャッシュを管理する仕組みです。Next.js 15では、ページセグメントのデフォルト `staleTime` が0秒になり、ページ遷移時に常に最新データが反映されるようになりました。

### Router Cacheは使用しない

現状、Router Cacheは `next.config.ts` でプロジェクト全体に対する設定しかできません。アプリケーションには、静的なコンテンツページもあれば、リアルタイム性が求められるダッシュボードのようなページも混在します。

## Data Cacheのルール（Legacy - Next.js 15）

> **⚠️ 注意**: Next.js 16では`use cache`が推奨されます。Data Cacheは後方互換性のために残されていますが、新規実装では`use cache`を使用してください。

Data Cacheは、サーバー側でfetchリクエストの結果をキャッシュする仕組みです。Next.js 15からはデフォルトで無効になっています。

### 1. Next.js 16への移行を推奨

新規実装や既存コードの更新時は、Data Cacheから`use cache`への移行を推奨します。

```typescript
// Before: Data Cache (Next.js 15)
export async function fetchPosts(): Promise<Result<Post[]>> {
  return await request<Post[]>('/api/posts', {
    next: {
      tags: ['posts'],
      revalidate: 3600,
    },
  })
}

// After: use cache (Next.js 16)
export async function fetchPosts() {
  'use cache'
  cacheTag('posts')
  cacheLife('hours') // 3600秒 = 1時間
  
  const res = await fetch('/api/posts')
  const data = await res.json()
  return data
}

// または、DBクエリを直接キャッシュ
async function getPosts() {
  'use cache'
  cacheTag('posts')
  cacheLife('hours')
  
  return await db.query('SELECT * FROM posts')
}

export async function fetchPosts(): Promise<Result<Post[]>> {
  try {
    const data = await getPosts()
    return { isSuccess: true, data }
  } catch (error) {
    return { isSuccess: false, errorMessage: 'Failed to fetch posts' }
  }
}
```

### 2. Data Cacheを使う場合のルール（既存コード向け）

既存のData Cacheを使用しているコードについては、以下のルールを適用します：

#### 2-1. revalidatePathは使わずrevalidateTagを使用

Data Cacheを再検証する際は、 `revalidatePath` ではなく `revalidateTag` を使用します。そのため、すべてのfetch関数には必ず `next.tags` を付与するルールとします。

`revalidatePath` は、指定したルート全体のキャッシュを一括削除します。つまり、更新する必要のないData Cacheまで削除してしまい、無駄なAPIリクエストが発生します。

一方、 `revalidateTag` は、タグを指定して必要な部分だけを再検証できます。

#### 2-2. サンプルコード

apis/posts.server.ts

```ts
import { request } from '@/lib/request';
import type { Result } from '@/types/result';
import type { Post } from '@/types/post';

export async function fetchPosts(): Promise<Result<Post[]>> {
  return await request<Post[]>('/api/posts', {
    next: {
      tags: ['posts'],
      revalidate: 3600,
    },
  });
}

export async function fetchPost(id: string): Promise<Result<Post>> {
  return await request<Post>(`/api/posts/${id}`, {
    next: {
      tags: [`post-${id}`],
    },
  });
}
```

actions/posts.ts

```ts
'use server';

import { createPostAPI } from '@/apis/posts.server';
import { revalidateTag } from 'next/cache';
import type { Result } from '@/types/result';

export async function createPost(data: { title: string }): Promise<Result<void>> {
  const result = await createPostAPI(data);

  if (result.isSuccess) {
    revalidateTag('posts');
  }

  return result;
}
```

## Request Memoizationのルール

Request Memoizationは、同一レンダー内で同じfetchリクエストが重複している場合、自動的に結果を再利用する仕組みです。

Request Memoizationはデフォルトで適用され、制御する手段がありません。そのため、特別な設定をせず、そのまま使用します。

## クライアントキャッシュのルール（TanStack Query）

クライアント側でのデータフェッチには、TanStack Query（React Query）のキャッシュ機構を使用します。

### 1. Data Cacheとの併用は避ける

TanStack QueryとNext.jsのfetchを併用する場合（Server ComponentsでのprefetchやRoute Handlerなど）は、Data Cacheをオフにします。

理由は、2つのキャッシュレイヤーを同時に使用すると、キャッシュの整合性管理が非常に複雑になるためです。

### 2. revalidate時はまずinvalidateQueriesを使用

キャッシュを再検証する際は、基本的に `invalidateQueries` を使用します。これは、シンプルな実装でUIとDBの整合性を担保できるためです。

ただし、必要に応じて `refetchQueries` や `removeQueries` も使い分けます。

### 3. SSR + Hydrationでの二重取得を避ける

Server ComponentsでprefetchしてHydrationする場合、サーバーとクライアントで同じデータを二重に取得しないよう注意が必要です。

具体的には、以下を確認します：

- `queryKey` がサーバーとクライアントで一致しているか
- `staleTime` や `refetchOnMount` などのオプションが適切に設定されているか

これにより、サーバー側で取得したデータをクライアント側で再利用でき、無駄なネットワークリクエストを削減できます。

## キャッシュ戦略のベストプラクティス

### 1. use cacheを優先的に使用（Next.js 16推奨）

サーバー側でのキャッシュには、`use cache`を優先的に使用します。

#### キャッシュ設計フロー

```
1. データの性質を分析
   ├─ 更新頻度（高/中/低）
   ├─ 共有範囲（全ユーザー/個別ユーザー/セッション）
   └─ リアルタイム性の要求（必須/不要）

2. キャッシュ戦略を選択
   ├─ リアルタイム必須 → キャッシュなし（Suspense + 動的レンダリング）
   ├─ 全ユーザー共有 → use cache + cacheLife + cacheTag
   ├─ 個別ユーザー → use cache: private + cacheLife + cacheTag
   └─ ランタイムAPI使用 → Suspenseでラップ（キャッシュ不可）

3. タグ設計（細かく再検証できるように）
   ├─ リソース単位: 'posts', 'products', 'categories'
   ├─ ID単位: 'post-123', 'product-456'
   └─ ユーザー単位: 'user-789-cart'

4. cacheLifeの選択
   ├─ 'seconds' (5秒) - ほぼリアルタイム
   ├─ 'minutes' (5分) - 高頻度更新データ
   ├─ 'hours' (1時間) - 中頻度更新データ
   ├─ 'days' (1日) - 低頻度更新データ
   └─ カスタム: { stale: 60, revalidate: 3600 }
```

#### 適用レベル別の推奨

- **ユーティリティ関数**: DBクエリやAPI呼び出しをラップした関数に`use cache`
- **コンポーネント**: 静的・半静的なコンポーネントに`use cache`
- **ページ**: 完全静的なページに`use cache`（動的部分はSuspenseで分離）

#### キャッシュ判断基準

- **キャッシュする**: マスタデータ、コンテンツ、低頻度更新データ
- **キャッシュしない**: リアルタイムデータ、ユーザーセッション、高頻度更新データ
- **迷ったら**: まずキャッシュせず、パフォーマンス測定後に判断

### 2. updateTag/revalidateTagで細かく再検証

キャッシュの再検証には、タグベースの管理を使用します。

- **updateTag**: ユーザー操作直後に即座に反映が必要（カート、お気に入りなど）
- **revalidateTag**: 次回リクエスト時の反映で問題ない（コンテンツ、記事一覧など）
- **タグ設計**: リソース単位、ID単位、ユーザー単位で細かく設計
- **revalidatePath**: 使用しない（全体を無効化してしまうため）

```typescript
// ✅ Good: 細かいタグ設計
cacheTag('posts', `post-${id}`, `author-${authorId}`)

// ❌ Bad: 粗いタグ設計
cacheTag('data')
```

### 3. Full Route Cacheは静的ページで活用

静的コンテンツページでは、Full Route Cacheを有効にしてパフォーマンスを最大化します。

- **ルートグループで分離**: `(static)` と `(dynamic)` のようにディレクトリを分ける
- **ルートレイアウトで動的API禁止**: 全画面が動的レンダリングになるのを防ぐ
- **PPR（Partial Prerendering）**: 静的部分と動的部分を`Suspense`で分離

### 4. クライアントフェッチはTanStack Queryで一元管理

クライアント側のデータフェッチとキャッシュは、TanStack Queryで統一します。

- **use cacheとの併用は避ける**: サーバー側は`use cache`、クライアント側はTanStack Queryで分離
- **適切なオプション設定**: `staleTime` 、 `gcTime` 、 `refetchOnMount` などを最適化
- **再検証は `invalidateQueries` を基本**: シンプルで安全な実装を優先

### 5. 段階的な最適化アプローチ

```
フェーズ1: 動的レンダリング（デフォルト）
  └─ まずは全て動的レンダリングで実装

フェーズ2: 静的部分の特定
  └─ パフォーマンス測定、静的にできる部分を特定

フェーズ3: use cacheの適用
  └─ 特定した部分に`use cache`を適用

フェーズ4: 監視と調整
  └─ キャッシュヒット率、エラー率を監視し調整
```

## 実践例：Todoアプリへの適用

### APIクライアント層

```typescript
// src/app/(private)/todo/_apis/todos.server.ts
import { cacheTag, cacheLife } from 'next/cache'

// ✅ ユーザー固有のTodoリストはprivateキャッシュ
export async function fetchTodos(userId: string) {
  'use cache: private'
  cacheTag(`todos-${userId}`)
  cacheLife('minutes') // 5分キャッシュ
  
  const res = await fetch(`${process.env.API_URL}/todos?userId=${userId}`)
  const data = await res.json()
  return data
}
```

### Server Actions層

```typescript
// src/app/(private)/todo/_actions/toggleTodo.ts
import { updateTag } from 'next/cache'

export async function toggleTodoAction(userId: string, todoId: string) {
  'use server'
  
  // Todoの状態を更新
  await updateTodoStatus(todoId)
  
  // 即座にキャッシュを更新
  updateTag(`todos-${userId}`)
}
```

### コンポーネント層

```tsx
// src/app/(private)/todo/page.tsx
import { Suspense } from 'react'
import { TodoList } from './_components/TodoList'

export default function TodoPage() {
  return (
    <div>
      <h1>Todos</h1>
      <Suspense fallback={<TodoListSkeleton />}>
        <TodoList />
      </Suspense>
    </div>
  )
}
```

この戦略により、パフォーマンスとユーザー体験のバランスを保ちながら、予測可能で保守性の高いキャッシュ管理が実現できます。
